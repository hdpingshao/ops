##### 上一节，讲了 CPU 上下文切换的工作原理。简单回顾一下，CPU 上下文切换是保证 Linux 系统正常工作的一个核心功能，按照不同场景，可以分为进程上下文切换、线程上下文切换和中断上下文切换。

##### 下面我们就来研究，究竟怎么分析 CPU 上下文切换的问题。

##### 怎么查看系统的上下文切换情况，通过前面文章我们知道，过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，缩短进程真正运行的时间，成了系统性能大幅下降的一个元凶。

##### 既然上下文切换对系统性能影响那么大，你肯定迫不及待想知道，到底要怎么查看上下文切换呢？在这里，我们可以使用 vmstat 这个工具，来查询系统的上下文切换情况。

##### vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。

##### 比如，下面就是一个 vmstat 的使用示例：

	# 每隔 5 秒输出 1 组数据
	[root@localhost ~]# vmstat 5
	procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
	 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
	 0  0     28 123108   2100 3553932    0    0     2     5    5    7  0  0 100  0  0

##### 我们一起来看这个结果，你可以先试着自己解读每列的含义。在这里，我重点强调下，需要特别关注的四列内容：

##### cs（context switch）是每秒上下文切换的次数。

##### in（interrupt）则是每秒中断的次数。

##### r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。

##### b（Blocked）则是处于不可中断睡眠状态的进程数。

##### 可以看到，这个例子中的上下文切换次数 cs 是 7 次，而系统中断次数 in 则是 5 次，而就绪队列长度 r 和不可中断状态进程数 b 都是 0。

##### vmstat 只给出了系统总体的上下文切换情况，要想查看每个进程的详细情况，就需要使用我们前面提到过的 pidstat 了。给它加上 -w 选项，你就可以查看每个进程上下文切换的情况了。

##### 比如说：

	# 每隔 5 秒输出 1 组数据
	[root@localhost ~]# pidstat -w 5
	Linux 3.10.0-514.2.2.el7.x86_64 (localhost.localdomain)         01/18/2019      _x86_64_        (2 CPU)

	06:01:02 PM   UID       PID   cswch/s nvcswch/s  Command
	06:01:07 PM     0         3      0.20      0.00  ksoftirqd/0
	06:01:07 PM     0         9     17.17      0.00  rcu_sched
	06:01:07 PM     0        10      0.20      0.00  watchdog/0
	06:01:07 PM     0        11      0.20      0.00  watchdog/1
	06:01:07 PM     0        13      0.20      0.00  ksoftirqd/1
	06:01:07 PM     0        34      0.20      0.00  khugepaged
	06:01:07 PM    32       660      0.20      0.00  rpcbind
	06:01:07 PM     0     23605     11.58      0.00  kworker/1:1
	06:01:07 PM     0     25153      0.40      0.00  kworker/1:0H
	06:01:07 PM     0     26456      0.40      0.00  kworker/1:2
	06:01:07 PM     0     27379      1.80      0.00  kworker/u4:1
	06:01:07 PM     0     27940      1.40      0.00  kworker/u4:2
	06:01:07 PM     0     27968      0.20      0.00  sshd
	06:01:07 PM     0     28031      1.00      0.00  kworker/0:2
	06:01:07 PM     0     28210      0.20      0.20  pidstat

##### 这个结果中有两列内容是我们的重点关注对象。一个是 cswch ，表示每秒自愿上下文切换（voluntary context switches）的次数，另一个则是 nvcswch ，表示每秒非自愿上下文切换（non voluntary context switches）的次数。

##### 这两个概念你一定要牢牢记住，因为它们意味着不同的性能问题：

##### 所谓自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。

##### 而非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。

##### 案例分析：知道了怎么查看这些指标，另一个问题又来了，上下文切换频率是多少次才算正常呢？别急着要答案，同样的，我们先来看一个上下文切换的案例。通过案例实战演练，你自己就可以分析并找出这个标准了。

### 准备：
##### 今天的案例，我们将使用 sysbench 来模拟系统多线程调度切换的情况。

##### sysbench:是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况。当然，在这次案例中，我们只把它当成一个异常进程来看，作用是模拟上下文切换过多的问题。

##### 我使用的案例环境如下所示：

##### 机器配置：2 CPU，4GB 内存

##### 预先安装 sysbench 和 sysstat 包，如 yum install sysbench sysstat

##### 正式操作开始前，你需要打开三个终端，登录到同一台 Linux机器中，并安装好上面提到的两个软件包。

##### 另外注意，下面所有命令，都默认以 root 用户运行。所以，如果你是用普通用户登陆的系统，记住先运行sudo su root 命令切换到 root 用户。

##### 安装完成后，你可以先用 vmstat 看一下空闲系统的上下文切换次数：

	# 间隔 1 秒后输出 1 组数据
	[root@localhost ~]# vmstat 1 1
	procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
	 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
	 0  0     28 121944   2100 3553984    0    0     2     5    5    7  0  0 100  0  0

##### 这里你可以看到，现在的上下文切换次数 cs 是 7，而中断次数 in 是 5，r 和 b 都是0。因为这会儿我并没有运行其他任务，所以它们就是空闲系统的上下文切换次数。

### 操作和分析:
##### 接下来，我们正式进入实战操作。

##### 首先，在第一个终端里运行 sysbench ，模拟系统多线程调度的瓶颈：

	# 以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题
	[root@localhost ~]# sysbench --threads=10 --max-time=300 threads run

##### 接着，在第二个终端运行 vmstat ，观察上下文切换情况：

	# 每隔 1 秒输出 1 组数据（需要 Ctrl+C 才结束）
	[root@localhost ~]# vmstat 1
	procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
	 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
	 7  0     28 118856   2100 3555300    0    0     2     5    5    6  0  0 100  0  0
	 5  0     28 118856   2100 3555300    0    0     0     0 3904 3305086 12 87  1  0  0
	 3  0     28 118856   2100 3555300    0    0     0     0 3931 3208232 11 88  1  0  0
	 7  0     28 118856   2100 3555300    0    0     0     0 3174 3323342 10 90  1  0  0

##### 你应该可以发现，cs 列的上下文切换次数从之前的 7 骤然上升到了 330 万。同时，注意观察其他几个指标：

##### r 列：就绪队列的长度已经到了 7，远远超过了系统 CPU 的个数 2，所以肯定会有大量的 CPU 竞争。

##### us（user）和 sy（system）列：这两列的 CPU 使用率加起来上升到了 100%，其中系统 CPU 使用率，也就是 sy 列高达 90%，说明 CPU 主要是被内核占用了。

##### in 列：中断次数也上升到了 4000 左右，说明中断处理也是个潜在的问题。

##### 综合这几个指标，我们可以知道，系统的就绪队列过长，也就是正在运行和等待 CPU 的进程数过多，导致了大量的上下文切换，而上下文切换又导致了系统 CPU 的占用率升高。

##### 那么到底是什么进程导致了这些问题呢？

##### 我们继续分析，在第三个终端再用 pidstat 来看一下， CPU 和进程上下文切换的情况：

	# 每隔 1 秒输出 1 组数据（需要 Ctrl+C 才结束）
	# -w 参数表示输出进程上下文切换指标，而 -u 参数则表示输出 CPU 使用指标
	[root@localhost ~]# pidstat -w -u 1
	Linux 3.10.0-514.2.2.el7.x86_64 (localhost.localdomain)         01/18/2019      _x86_64_        (2 CPU)

	06:11:28 PM   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
	06:11:29 PM     0     28232   22.77  175.25    0.00    0.00  198.02     0  sysbench

	06:11:28 PM   UID       PID   cswch/s nvcswch/s  Command
	06:11:29 PM     0         3      2.97      0.00  ksoftirqd/0
	06:11:29 PM     0         9     29.70      0.00  rcu_sched
	06:11:29 PM     0        10      0.99      0.00  watchdog/0
	06:11:29 PM     0        11      0.99      0.00  watchdog/1
	06:11:29 PM     0       657      0.99      0.00  irqbalance
	06:11:29 PM     0     23605     10.89      0.00  kworker/1:1
	06:11:29 PM     0     27379      1.98      0.00  kworker/u4:1
	06:11:29 PM     0     27940      0.99      0.00  kworker/u4:2
	06:11:29 PM     0     28031      0.99      0.00  kworker/0:2
	06:11:29 PM     0     28262      0.99      1.98  pidstat

##### 从 pidstat 的输出你可以发现，CPU 使用率的升高果然是 sysbench 导致的，它的 CPU 使用率已经达到了 200%(2核)。但上下文切换则是来自其他进程，包括非自愿上下文切换频率最高的 pidstat ，以及自愿上下文切换频率最高的内核线程 kworker 。

##### 不过，细心的你肯定也发现了一个怪异的事儿：pidstat 输出的上下文切换次数，加起来也就几十，比 vmstat 的 330 万明显小了太多。这是怎么回事呢？难道是工具本身出了错吗？

##### 别着急，在怀疑工具之前，我们再来回想一下，前面讲到的几种上下文切换场景。其中有一点提到， Linux 调度的基本单位实际上是线程，而我们的场景 sysbench 模拟的也是线程的调度问题，那么，是不是 pidstat 忽略了线程的数据呢？

##### 通过运行 man pidstat ，你会发现，pidstat 默认显示进程的指标数据，加上 -t 参数后，才会输出线程的指标。

##### 所以，我们可以在第三个终端里， Ctrl+C 停止刚才的 pidstat 命令，再加上 -t 参数，重试一下看看：

	# 每隔 1 秒输出一组数据（需要 Ctrl+C 才结束）
	# -wt 参数表示输出线程的上下文切换指标
	[root@localhost ~]# pidstat -wt 1
	Linux 3.10.0-514.2.2.el7.x86_64 (localhost.localdomain)         01/18/2019      _x86_64_        (2 CPU)

	06:14:39 PM   UID      TGID       TID   cswch/s nvcswch/s  Command
	06:14:40 PM     0         3         -      2.91      0.00  ksoftirqd/0
	06:14:40 PM     0         -         3      2.91      0.00  |__ksoftirqd/0
	06:14:40 PM     0         9         -     33.98      0.00  rcu_sched
	06:14:40 PM     0         -         9     33.98      0.00  |__rcu_sched
	06:14:40 PM     0         -      2145      0.97      0.00  |__tuned
	06:14:40 PM     0         -     23428      9.71      0.00  |__dockerd
	06:14:40 PM     0         -     23432      3.88      0.00  |__dockerd
	06:14:40 PM     0         -     23433      2.91      0.00  |__dockerd
	06:14:40 PM     0         -     23449      1.94      0.00  |__dockerd
	06:14:40 PM     0         -     28549      2.91      0.00  |__dockerd
	06:14:40 PM     0         -     30368      4.85      0.00  |__dockerd
	06:14:40 PM     0         -     23435      9.71      0.00  |__containerd
	06:14:40 PM     0         -     23436      1.94      0.00  |__containerd
	06:14:40 PM     0         -     23441      0.97      0.00  |__containerd
	06:14:40 PM     0         -     23444      1.94      0.00  |__containerd
	06:14:40 PM     0         -     23445      4.85      0.00  |__containerd
	06:14:40 PM     0         -     23446      5.83      0.00  |__containerd
	06:14:40 PM     0     23605         -     10.68      0.00  kworker/1:1
	06:14:40 PM     0         -     23605     10.68      0.00  |__kworker/1:1
	06:14:40 PM     0     25153         -      0.97      0.00  kworker/1:0H
	06:14:40 PM     0         -     25153      0.97      0.00  |__kworker/1:0H
	06:14:40 PM     0     27379         -      1.94      0.00  kworker/u4:1
	06:14:40 PM     0         -     27379      1.94      0.00  |__kworker/u4:1
	06:14:40 PM     0     27940         -      0.97      0.00  kworker/u4:2
	06:14:40 PM     0         -     27940      0.97      0.00  |__kworker/u4:2
	06:14:40 PM     0     28031         -      0.97      0.00  kworker/0:2
	06:14:40 PM     0         -     28031      0.97      0.00  |__kworker/0:2
	06:14:40 PM     0         -     28264  33989.32 323869.90  |__sysbench
	06:14:40 PM     0         -     28265  47995.15 258184.47  |__sysbench
	06:14:40 PM     0         -     28266  54685.44 290795.15  |__sysbench
	06:14:40 PM     0         -     28267  41034.95 285391.26  |__sysbench
	06:14:40 PM     0         -     28268  51218.45 291291.26  |__sysbench
	06:14:40 PM     0         -     28269  52643.69 253050.49  |__sysbench
	06:14:40 PM     0         -     28270  46833.01 272556.31  |__sysbench
	06:14:40 PM     0         -     28271  66969.90 254361.17  |__sysbench
	06:14:40 PM     0         -     28272  59986.41 238841.75  |__sysbench
	06:14:40 PM     0         -     28273  31473.79 310774.76  |__sysbench
	06:14:40 PM     0     28275         -      0.97      0.97  pidstat
	06:14:40 PM     0         -     28275      0.97      0.97  |__pidstat

##### 现在你就能看到了，虽然 sysbench 进程（也就是主线程）的上下文切换次数看起来并不多，但它的子线程的上下文切换次数却有很多。看来，上下文切换罪魁祸首，还是过多的 sysbench 线程。

##### 我们已经找到了上下文切换次数增多的根源，那是不是到这儿就可以结束了呢？

##### 当然不是。不知道你还记不记得，前面在观察系统指标时，除了上下文切换频率骤然升高，还有一个指标也有很大的变化。是的，正是中断次数。中断次数也上升到了 4000 ，但到底是什么类型的中断上升了，现在还不清楚。我们接下来继续抽丝剥茧找源头。

##### 既然是中断，我们都知道，它只发生在内核态，而 pidstat 只是一个进程的性能分析工具，并不提供任何关于中断的详细信息，怎样才能知道中断发生的类型呢？

##### 没错，那就是从 /proc/interrupts 这个只读文件中读取。/proc 实际上是 Linux 的一个虚拟文件系统，用于内核空间与用户空间之间的通信。/proc/interrupts 就是这种通信机制的一部分，提供了一个只读的中断使用情况。

##### 我们还是在第三个终端里， Ctrl+C 停止刚才的 pidstat 命令，然后运行下面的命令，观察中断的变化情况：

	# -d 参数表示高亮显示变化的区域
	[root@localhost ~]# watch -d cat /proc/interrupts
	CPU0 CPU1
	...
	RES: 2450431 5279697 Rescheduling interrupts
	...
	复制代码

##### 观察一段时间，你可以发现，变化速度最快的是重调度中断（RES），这个中断类型表示，唤醒空闲状态的 CPU 来调度新的任务运行。这是多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为处理器间中断（Inter-Processor Interrupts，IPI）。

##### 所以，这里的中断升高还是因为过多任务的调度问题，跟前面上下文切换次数的分析结果是一致的。

##### 通过这个案例，你应该也发现了多工具、多方面指标对比观测的好处。如果最开始时，我们只用了 pidstat 观测，这些很严重的上下文切换线程，压根儿就发现不了了。

##### 现在再回到最初的问题，每秒上下文切换多少次才算正常呢？

##### 这个数值其实取决于系统本身的 CPU 性能。在我看来，如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题。

##### 这时，你还需要根据上下文切换的类型，再做具体分析。比方说：

##### 自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；

##### 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；

##### 中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。

### 小结：
##### 今天，通过一个 sysbench 的案例，讲解了上下文切换问题的分析思路。碰到上下文切换次数过多的问题时，我们可以借助 vmstat 、 pidstat 和 /proc/interrupts 等工具，来辅助排查性能问题的根源。